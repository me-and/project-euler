#!/usr/bin/env python3
'''
Pentagon numbers

Pentagonal numbers are generated by the formula, P(n)=n(3n−1)/2. The first ten
pentagonal numbers are:

    1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P(4) + P(7) = 22 + 70 = 92 = P(8). However, their
difference, 70 − 22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, P(j) and P(k), for which their sum and
difference are pentagonal and D = |P(k) − P(j)| is minimised; what is the value
of D?
'''

from itertools import count, dropwhile, islice
import sys

from sequence import MonatonicIncreasingSequence

# The formula is quadratic, and is monatonic for n ≥ 1 (the minimum is at
# n=1/6).
pentagons = MonatonicIncreasingSequence((n * (3 * n - 1)) // 2
                                        for n in count(1))


def upper_bound():
    # Find an upper bound by assuming j < k and just considering all pentagonal
    # numbers in order.
    for k, p_k in enumerate(pentagons):
        for j, p_j in zip(range(k), pentagons):
            if (p_k - p_j) in pentagons and (p_k + p_j) in pentagons:
                return j, k, (p_k - p_j)


if __name__ == '__main__':
    upper_j, upper_k, bound = upper_bound()

    # This upper bound turns out to be the solution.  Which is rather
    # unsatisfying, because we haven't yet shown there isn't a better solution,
    # but my attempts to find an algorithm that does prove this is the best
    # solution haven't yielded anything in a reasonable runtime.
    print(bound)
    sys.exit(0)

    # We know D must be at most `bound`, so keep enumerating until the
    # difference between P(k) and P(k-1) is greater than `bound`, at which
    # point we know we have the best possible result.
    for k, p_k in islice(enumerate(pentagons), upper_k, None):
        if p_k - pentagons[k - 1] > bound:
            # Never going to find anything that beats bound.
            break

        for p_j in dropwhile(lambda p_j: p_j < p_k - bound,
                             islice(pentagons, k)):
            if ((p_k - p_j) in pentagons and
                    (p_k + p_j) in pentagons and
                    (p_k - p_j) < bound):
                bound = p_k - p_j

    print(bound)
