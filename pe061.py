#!/usr/bin/env python3
'''
Cyclical figurate numbers

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
all figurate (polygonal) numbers and are generated by the following formulae:

    Triangle        P(3,n)=n(n+1)/2       1, 3, 6, 10, 15, ...
    Square          P(4,n)=n^2            1, 4, 9, 16, 25, ...
    Pentagonal      P(5,n)=n(3n−1)/2      1, 5, 12, 22, 35, ...
    Hexagonal       P(6,n)=n(2n−1)        1, 6, 15, 28, 45, ...
    Heptagonal      P(7,n)=n(5n−3)/2      1, 7, 18, 34, 55, ...
    Octagonal       P(8,n)=n(3n−2)        1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
interesting properties.

1.  The set is cyclic, in that the last two digits of each number is the first
    two digits of the next number (including the last number with the first).

2.  Each polygonal type: triangle (P(3,127)=8128), square (P(4,91)=8281), and
    pentagonal (P(5,44)=2882), is represented by a different number in the set.

3.  This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which
each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
octagonal, is represented by a different number in the set.
'''

from itertools import permutations
from sys import argv

from polygons import (triangles, squares, pentagons, hexagons, heptagons,
                      octagons)


POLYGONS = (triangles, squares, pentagons, hexagons, heptagons, octagons)


def extend_chains(polygon, chain_list):
    '''Given chains, add possible new chains

    Given the polygon that the next element in the chain must be in, and the
    list of chains so far, produce a new list of chains that has all the
    possible next polygons while meeting the cyclic property.
    '''
    new_chain_list = []
    for chain in chain_list:
        last_two_digits = chain[-1] % 100
        if last_two_digits < 10:
            continue
        range_min = last_two_digits * 100
        range_max = range_min + 99
        for next_number in polygon.range(range_min, range_max):
            new_chain_list.append(chain + [next_number])
    return new_chain_list


def possible_chains(polygons):
    # Range can't be lower than 1010, since both the first and second number in
    # the sequence need to be four-digit numbers, and can't be higher than 9999
    # else it wouldn't be a four-digit number at all.
    chains = [[number] for number in polygons[0].range(1010, 9999)]
    for polygon in polygons[1:]:
        chains = extend_chains(polygon, chains)

    # The extension function doesn't check the final element completes the
    # chain, since it doesn't know or care which element is final.  Remove
    # chains that don't complete the loop now.
    chains = [chain for chain in chains if chain[0] // 100 == chain[-1] % 100]
    return chains


if __name__ == '__main__':
    try:
        size = int(argv[1])
    except IndexError:
        size = 6

    # Without loss of generality, assume the sequence starts with the triangle
    # numbers, and consider all possible permutations of the remaining polygons.
    for polygon_sequence in permutations(POLYGONS[1:size]):
        for solution in possible_chains((triangles,) + polygon_sequence):
            print(sum(solution))
